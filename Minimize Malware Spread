In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
Some nodes initial are initially infected by malware.  
Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, 
both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.
We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  
If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, 
it may still be infected later as a result of the malware spread.
1. 给定一个用图表示的网络，如果graph[i][j] = 1, 说明节点i和j之间有连接
2. 如果一个节点被病毒感染，所有和这个节点有连接的节点都会被病毒感染，并且会不断扩散
3. 输入一个初始节点数组，表示已经感染病毒的节点

问题，假如从初始节点中删除一个节点，选择哪个节点会使得最后已感染病毒的节点最少？

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0
Example 3:

Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1
 

Note:

1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length
下面的代码里面，只统计了每个节点分别能够感染多少台机器，但是没有处理重复的情况， 也就是说，有两个initial node都可以感染同一批机器，
那么即使这两个node可以感染最多的机器，remove单个以后不会减少被感染的node，因为remove单个以后另外一个仍然可以感染这些。

0--1--2

3--4

虽然0和1都可以感染3个节点，但是无论删除0还是1都不会减少被感染的node, 反而remove 3可以减少被感染的node。
所以这个case应该返回3而不是0

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        n = len(graph)
        parents = range(n)
        def find(x):
            if x!= parents[x]:
                parents[x] = find(parents[x])
            return parents[x]
        def union(x, y):
            parents[find(x)] = find(y)
        
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    union(i, j)
        area = collections.Counter(find(i) for i in range(n))
        malware = collections.Counter(find(i) for i in initial)
        save = 0
        res = min(initial)
        for i in initial:
            if malware[find(i)] == 1:
                if area[find(i)] > save:
                    save,res = area[find(i)], i
                elif area[find(i)] == save:
                    res = min(res, i)
        return res
